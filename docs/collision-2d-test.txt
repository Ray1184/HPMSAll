import java.util.ArrayList;
import java.util.List;

List<PVector> points;
int SIDES = 11;
PVector[] sortedPoints = new PVector[SIDES * 2];
int[] fx = new int[] {3, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11};
int[] fy = new int[] {5, 2, 4, 3, 6, 7, 8, 9, 10, 11, 1};
int factor = 20;
boolean inside = false;
PVector mousePos = new PVector(0, 0);
PVector delta = new PVector(0, 0);
String objData = "v -1.000000 -1.000000 0.000000"
  + "\nv 1.000000 -1.000000 0.000000"
  + "\nv -1.505155 1.137769 0.000000"
  + "\nv 3.365042 2.033271 0.000000"
  + "\nv -0.678538 3.893158 0.000000"
  + "\nv -5.408622 3.824274 0.000000"
  + "\nv -8.301780 0.265230 0.000000"
  + "\nv -5.615276 -4.097469 0.000000"
  + "\nv 7.495781 -0.102155 0.000000"
  + "\nv 6.003279 0.196345 0.000000"
  + "\nv -0.104498 -1.801312 0.000000"
  + "\nl 3 5"
  + "\nl 1 2"
  + "\nl 2 4"
  + "\nl 4 3"
  + "\nl 5 6"
  + "\nl 6 7"
  + "\nl 7 8"
  + "\nl 8 9"
  + "\nl 9 10"
  + "\nl 10 11"
  + "\nl 11 1";

PVector[] loadSortedSizesObj(String data) {
  String[] lines = data.split("\r\n");
  List<PVector> sortedData = new ArrayList<PVector>();
  List<PVector> vertices = new ArrayList<PVector>();
  List<Integer> sides = new ArrayList<Integer>();
  for (String line : lines) {
    char type = line.charAt(0);
    String content = line.substring(2).trim();
    String[] tokens = content.split(" ");
    switch (type) {
    case 'v':
      vertices.add(new PVector(Float.parseFloat(tokens[0]), Float.parseFloat(tokens[1]), Float.parseFloat(tokens[2])));
      break;
    case 'l':
      sides.add(Integer.parseInt(tokens[0]), Integer.parseInt(tokens[1]));
      break;
    }
  }
  
  return sortedData.toArray(new PVector[sortedData.size()]);
}

void setup() {
  size(640, 360);
  points = new ArrayList<PVector>();
  points.add(new PVector(-1.000000, -1.000000));
  points.add(new PVector(1.000000, -1.000000 ));
  points.add(new PVector(-1.505155, 1.137769 ));
  points.add(new PVector(3.365042, 2.033271  ));
  points.add(new PVector(-0.678538, 3.893158 ));
  points.add(new PVector(-5.408622, 3.824274 ));
  points.add(new PVector(-8.301780, 0.265230 ));
  points.add(new PVector(-5.615276, -4.097469));
  points.add(new PVector(7.495781, -0.102155 ));
  points.add(new PVector(6.003279, 0.196345  ));
  points.add(new PVector(-0.104498, -1.801312));

  int c = 0;
  for (int i = 0; i < sortedPoints.length; i += 2) {
    sortedPoints[i] = new PVector(points.get(fx[c] - 1).x, points.get(fx[c] - 1).y);
    sortedPoints[i + 1] = new PVector(points.get(fy[c] - 1).x, points.get(fy[c] - 1).y);
    c++;
  }
}

void draw() {
  background(0);
  mousePos.set(mouseX, mouseY);
  inside = pointInsidePolygon(mousePos, delta, sortedPoints);
  if (inside) {
    stroke(255, 0, 0);
    strokeWeight(3);
  } else {
    stroke(255);
    strokeWeight(1);
  }
  translate(400, 200);
  for (int i = 0; i < SIDES * 2; i += 2) {
    line(sortedPoints[i].x * factor, sortedPoints[i].y * factor, sortedPoints[i + 1].x * factor, sortedPoints[i + 1].y * factor);
  }
}


boolean pointInsidePolygon(PVector point, PVector t, PVector[] data)
{
  float x1, y1, x2, y2;
  int len = data.length;
  x2 = data[len].x + t.x;
  y2 = data[len].y + t.y;
  int wn = 0;
  for (int idx = 0; idx < len; idx++)
  {
    x1 = x2;
    y1 = y2;
    x2 = data[idx].x + t.x;
    y2 = data[idx].y + t.y;
    if (y1 > point.y)
    {
      if ((y2 <= point.y) && (x1 - point.x) * (y2 - point.y) < (x2 - point.x) * (y1 - point.y))
      {
        wn++;
      } else if ((y2 > point.y) && (x1 - point.x) * (y2 - point.y) > (x2 - point.x) * (y1 - point.y))
      {
        wn--;
      }
    }
  }
  return wn % 2 != 0;
}
